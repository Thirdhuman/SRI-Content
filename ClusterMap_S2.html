<html>

<head>
    <meta charset='utf-8' />
    <title>Opportunity Zones</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
    <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v1.3.1/mapbox-gl.js'></script>
    <script
    (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
        (function (global, factory) {
        typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
        typeof define === 'function' && define.amd ? define(factory) :
        (global = global || self, global.TinyQueue = factory());
        }(this, function () { 'use strict';
        
        var TinyQueue = function TinyQueue(data, compare) {
            if ( data === void 0 ) data = [];
            if ( compare === void 0 ) compare = defaultCompare;
        
            this.data = data;
            this.length = this.data.length;
            this.compare = compare;
        
            if (this.length > 0) {
                for (var i = (this.length >> 1) - 1; i >= 0; i--) { this._down(i); }
            }
        };
        
        TinyQueue.prototype.push = function push (item) {
            this.data.push(item);
            this.length++;
            this._up(this.length - 1);
        };
        
        TinyQueue.prototype.pop = function pop () {
            if (this.length === 0) { return undefined; }
        
            var top = this.data[0];
            var bottom = this.data.pop();
            this.length--;
        
            if (this.length > 0) {
                this.data[0] = bottom;
                this._down(0);
            }
        
            return top;
        };
        
        TinyQueue.prototype.peek = function peek () {
            return this.data[0];
        };
        
        TinyQueue.prototype._up = function _up (pos) {
            var ref = this;
                var data = ref.data;
                var compare = ref.compare;
            var item = data[pos];
        
            while (pos > 0) {
                var parent = (pos - 1) >> 1;
                var current = data[parent];
                if (compare(item, current) >= 0) { break; }
                data[pos] = current;
                pos = parent;
            }
        
            data[pos] = item;
        };
        
        TinyQueue.prototype._down = function _down (pos) {
            var ref = this;
                var data = ref.data;
                var compare = ref.compare;
            var halfLength = this.length >> 1;
            var item = data[pos];
        
            while (pos < halfLength) {
                var left = (pos << 1) + 1;
                var best = data[left];
                var right = left + 1;
        
                if (right < this.length && compare(data[right], best) < 0) {
                    left = right;
                    best = data[right];
                }
                if (compare(best, item) >= 0) { break; }
        
                data[pos] = best;
                pos = left;
            }
        
            data[pos] = item;
        };
        
        function defaultCompare(a, b) {
            return a < b ? -1 : a > b ? 1 : 0;
        }
        
        return TinyQueue;
        
        }));
        
        },{}],2:[function(require,module,exports){
        'use strict';
        
        var Queue = require('tinyqueue');
        
        module.exports = polylabel;
        module.exports.default = polylabel;
        
        function polylabel(polygon, precision, debug) {
            precision = precision || 1.0;
        
            // find the bounding box of the outer ring
            var minX, minY, maxX, maxY;
            for (var i = 0; i < polygon[0].length; i++) {
                var p = polygon[0][i];
                if (!i || p[0] < minX) minX = p[0];
                if (!i || p[1] < minY) minY = p[1];
                if (!i || p[0] > maxX) maxX = p[0];
                if (!i || p[1] > maxY) maxY = p[1];
            }
        
            var width = maxX - minX;
            var height = maxY - minY;
            var cellSize = Math.min(width, height);
            var h = cellSize / 2;
        
            if (cellSize === 0) return [minX, minY];
        
            // a priority queue of cells in order of their "potential" (max distance to polygon)
            var cellQueue = new Queue(undefined, compareMax);
        
            // cover polygon with initial cells
            for (var x = minX; x < maxX; x += cellSize) {
                for (var y = minY; y < maxY; y += cellSize) {
                    cellQueue.push(new Cell(x + h, y + h, h, polygon));
                }
            }
        
            // take centroid as the first best guess
            var bestCell = getCentroidCell(polygon);
        
            // special case for rectangular polygons
            var bboxCell = new Cell(minX + width / 2, minY + height / 2, 0, polygon);
            if (bboxCell.d > bestCell.d) bestCell = bboxCell;
        
            var numProbes = cellQueue.length;
        
            while (cellQueue.length) {
                // pick the most promising cell from the queue
                var cell = cellQueue.pop();
        
                // update the best cell if we found a better one
                if (cell.d > bestCell.d) {
                    bestCell = cell;
                    if (debug) console.log('found best %d after %d probes', Math.round(1e4 * cell.d) / 1e4, numProbes);
                }
        
                // do not drill down further if there's no chance of a better solution
                if (cell.max - bestCell.d <= precision) continue;
        
                // split the cell into four cells
                h = cell.h / 2;
                cellQueue.push(new Cell(cell.x - h, cell.y - h, h, polygon));
                cellQueue.push(new Cell(cell.x + h, cell.y - h, h, polygon));
                cellQueue.push(new Cell(cell.x - h, cell.y + h, h, polygon));
                cellQueue.push(new Cell(cell.x + h, cell.y + h, h, polygon));
                numProbes += 4;
            }
        
            if (debug) {
                console.log('num probes: ' + numProbes);
                console.log('best distance: ' + bestCell.d);
            }
        
            return [bestCell.x, bestCell.y];
        }
        
        function compareMax(a, b) {
            return b.max - a.max;
        }
        
        function Cell(x, y, h, polygon) {
            this.x = x; // cell center x
            this.y = y; // cell center y
            this.h = h; // half the cell size
            this.d = pointToPolygonDist(x, y, polygon); // distance from cell center to polygon
            this.max = this.d + this.h * Math.SQRT2; // max distance to polygon within a cell
        }
        
        // signed distance from point to polygon outline (negative if point is outside)
        function pointToPolygonDist(x, y, polygon) {
            var inside = false;
            var minDistSq = Infinity;
        
            for (var k = 0; k < polygon.length; k++) {
                var ring = polygon[k];
        
                for (var i = 0, len = ring.length, j = len - 1; i < len; j = i++) {
                    var a = ring[i];
                    var b = ring[j];
        
                    if ((a[1] > y !== b[1] > y) &&
                        (x < (b[0] - a[0]) * (y - a[1]) / (b[1] - a[1]) + a[0])) inside = !inside;
        
                    minDistSq = Math.min(minDistSq, getSegDistSq(x, y, a, b));
                }
            }
        
            return (inside ? 1 : -1) * Math.sqrt(minDistSq);
        }
        
        // get polygon centroid
        function getCentroidCell(polygon) {
            var area = 0;
            var x = 0;
            var y = 0;
            var points = polygon[0];
        
            for (var i = 0, len = points.length, j = len - 1; i < len; j = i++) {
                var a = points[i];
                var b = points[j];
                var f = a[0] * b[1] - b[0] * a[1];
                x += (a[0] + b[0]) * f;
                y += (a[1] + b[1]) * f;
                area += f * 3;
            }
            if (area === 0) return new Cell(points[0][0], points[0][1], 0, polygon);
            return new Cell(x / area, y / area, 0, polygon);
        }
        
        // get squared distance from a point to a segment
        function getSegDistSq(px, py, a, b) {
        
            var x = a[0];
            var y = a[1];
            var dx = b[0] - x;
            var dy = b[1] - y;
        
            if (dx !== 0 || dy !== 0) {
        
                var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);
        
                if (t > 1) {
                    x = b[0];
                    y = b[1];
        
                } else if (t > 0) {
                    x += dx * t;
                    y += dy * t;
                }
            }
        
            dx = px - x;
            dy = py - y;
        
            return dx * dx + dy * dy;
        }
        },{"tinyqueue":1}]},{},[2]); ></script>
    <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v1.3.1/mapbox-gl.css' rel='stylesheet' />

    <style>
        body {
            color: #404040;
            font: 400 15px/22px 'Source Sans Pro', 'Helvetica Neue', Sans-serif;
            margin: 0;
            padding: 0;
            -webkit-font-smoothing: antialiased;
            margin: 0;
            padding: 0;
        }

        #map {
            /* border-left: 1px solid #fff; */
            position: relative;
            /* left: 33.3333%;
            width: 66.6666%; */
            top: 0;
            bottom: 0;
        }

        .mapboxgl-popup {
            max-width: 1200px;
            font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
        }

        .pad2 {
            padding: 20px;
            -webkit-box-sizing: border-box;
            -moz-box-sizing: border-box;
            box-sizing: border-box;
        }

        .mapboxgl-ctrl-logo {
            display: none !important;
        }


        .listings {
            height: 100%;
            overflow: auto;
            padding-bottom: 60px;
        }

        .sidebar {
            position: relative;
            width: 33.3333%;
            height: 100%;
            top: 0;
            background: rgba(0, 0, 0, 0.3);
            left: 0;
            overflow: hidden;

        }
    </style>
</head>

<body>
    <div id='map' class='map' style='width: 100%; height: 850px;'></div>
    <!-- <script src="https://cdn.jsdelivr.net/combine/npm/@mapbox/polylabel@1.0.2,npm/tinyqueue@2.0.3"></script> -->
    <script>
        // var bounds = [
        // [-120, -20], // Southwest coordinates
        // [45, -80] // Northeast coordinates
        // ];

        // var filterGroup = document.getElementById('filter-group');
        mapboxgl.accessToken =
            'pk.eyJ1IjoidGhpcmRodW1hbiIsImEiOiJjamljYXUyeTcwNHBlM3hxb3dtZWtiMmFpIn0.5BIldxj0ATxmuJBaknExeQ';
        var map = new mapboxgl.Map({
            container: 'map',
            zoomControl: false,
            style: 'mapbox://styles/thirdhuman/ck04kj0h30l2o1crz23guljy8',
            // center: [-93.85, 37.45],
            // zoom: 4.31
            // maxBounds: bounds // Sets bounds as max
        });

        var hoveredStateId = null;
        // const polylabel = require('polylabel');



        map.on('load', function () {

            map.on('click', 'tract-shapes', function (e) {
                new mapboxgl.Popup()
                    .setLngLat(e.lngLat)
                    .setHTML(
                        "<strong>Tract Number: </strong>" + e.features[0].properties.GEOID
                        + "<br />" + "<strong>Tract Type: </strong>" + e.features[0].properties.Final_Cluster
                        + "<br />" + "<strong>Opportunity Zone Status: </strong>" + e.features[0].properties.OZ
                        + "<br />" + "<strong>Index_Placeholder: </strong>" + e.features[0].properties.ind1
                    )
                    .addTo(map);
            });

            map.on('click', 'state-shapes', function (e) {
                console.log(e.features[0].geometry.coordinates);
                var polys = e.features[0].geometry.coordinates;
                // var merged = flatten(polys);
                console.log(polys);
                console.log(polylabel);
                var p = polylabel(polys, 1);
                console.log(p);
                map.flyTo({ center: p });
            });

            // Change the cursor to a pointer when the it enters a feature in the 'symbols' layer.
            map.on('mouseenter', 'state-shapes', function () {
                map.getCanvas().style.cursor = 'pointer';
            });

            // Change it back to a pointer when it leaves.
            map.on('mouseleave', 'state-shapes', function () {
                map.getCanvas().style.cursor = '';
            });

            // console.log(test1)
            var test2 = map.queryRenderedFeatures({ layers: ['state-shapes'] });
            console.log(test2[0])
            // var test3 = map.queryRenderedFeatures({ layers: ['state-fills'] });
            // console.log(test3)

            // console.log(test3.id)

            map.on("mousemove", "state-shapes", function (e) {
                console.log(e.features[0].id)
                // console.log(e.features.length)
                console.log(hoveredStateId)
                if (e.features.length > 0) {
                    if (hoveredStateId) {
                        map.setFeatureState({
                            source: 'composite',
                            sourceLayer: "state_shapes_ab",
                            id: hoveredStateId
                        }, { hover: false });
                    }
                    hoveredStateId = e.features[0].id;
                    console.log(hoveredStateId)
                    map.setFeatureState({
                        source: 'composite',
                        sourceLayer: "state_shapes_ab",
                        id: hoveredStateId
                    }, { hover: true });
                    console.log(hoveredStateId)

                }
            });

            // When the mouse leaves the state-fill layer, update the feature state of the
            // previously hovered feature.
            map.on("mouseleave", "state-shapes", function () {
                if (hoveredStateId) {
                    map.setFeatureState({
                        source: 'composite',
                        sourceLayer: "state_shapes_ab",
                        id: hoveredStateId
                    }, { hover: false });
                }
                hoveredStateId = null;
            });

            map.scrollZoom.disable();
        });


    </script>

</body>

</html>